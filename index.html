<!DOCTYPE html>
<html lang="en">
<head>
	<!-- Basic Meta Tags -->
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Browser-based LUT Maker - Create Custom Color Lookup Tables</title>
	<meta name="description" content="Create custom LUTs (Look-Up Tables) for OBS and video editing directly in your browser. Transform colors using reference charts with this free, open-source tool.">

	<!-- Favicon -->
	<link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cmVjdCB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9IiNmMmYyZjIiIHJ4PSIyIiByeT0iMiIgLz4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyLCAyKSI+CiAgICA8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjNGE2ZmE1IiAvPgogICAgPHJlY3QgeD0iNCIgd2lkdGg9IjQiIGhlaWdodD0iNCIgZmlsbD0iIzQ3YjhkNiIgLz4KICAgIDxyZWN0IHg9IjgiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiIGZpbGw9IiM5MGVlOTAiIC8+CiAgICA8cmVjdCB5PSI0IiB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjZjViYTdkIiAvPgogICAgPHJlY3QgeD0iNCIgeT0iNCIgd2lkdGg9IjQiIGhlaWdodD0iNCIgZmlsbD0iI2NjY2NjYyIgLz4KICAgIDxyZWN0IHg9IjgiIHk9IjQiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiIGZpbGw9IiNjMzZlNzAiIC8+CiAgICA8cmVjdCB5PSI4IiB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjNDQzMzY2IiAvPgogICAgPHJlY3QgeD0iNCIgeT0iOCIgd2lkdGg9IjQiIGhlaWdodD0iNCIgZmlsbD0iIzMzMzMzMyIgLz4KICAgIDxyZWN0IHg9IjgiIHk9IjgiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiIGZpbGw9IiMwMDAwMDAiIC8+CiAgPC9nPgo8L3N2Zz4K" type="image/svg+xml">

	<!-- SEO Keywords -->
	<meta name="keywords" content="LUT, color grading, OBS, streaming, video editing, color correction, lookup table, color calibration, color cards, color charts, SpyderCHECKR, camera calibration, browser tool, free LUT maker, color transformation, color profile">

	<!-- Author Information -->
	<meta name="author" content="Steve Seguin">

	<!-- Open Graph / Social Media -->
	<meta property="og:title" content="Browser-based LUT Maker">
	<meta property="og:description" content="Create custom LUTs for OBS and video editing directly in your browser with this free tool.">
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://steveseguin.github.io/LUT-maker/">

	<!-- Twitter Card -->
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:title" content="Browser-based LUT Maker">
	<meta name="twitter:description" content="Create custom color lookup tables (LUTs) for OBS and video editing directly in your browser.">

	<!-- Additional SEO -->
	<meta name="robots" content="index, follow">
	<link rel="canonical" href="https://steveseguin.github.io/LUT-maker/">

	<!-- App Capability -->
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="apple-mobile-web-app-title" content="LUT Maker">

	<!-- Theme Color -->
	<meta name="theme-color" content="#4a6fa5">
	
    <style>
 :root {
    --primary-color: #4a6fa5;
    --primary-dark: #3a5a80;
    --secondary-color: #47b8d6;
    --dark-color: #333;
    --light-color: #f4f4f4;
    --danger-color: #dc3545;
    --success-color: #28a745;
    --bg-color: #f8f9fa;
    --card-bg: #ffffff;
    --border-radius: 8px;
    --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    --transition: all 0.3s ease;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    line-height: 1.6;
    color: var(--dark-color);
    background: var(--bg-color);
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

h1, h2, h3 {
    margin-bottom: 10px;
    color: var(--primary-color);
    font-weight: 600;
}

h1 {
    font-size: 2.2rem;
    margin-bottom: 0.5rem;
}

h2 {
    font-size: 1.6rem;
    margin-top: 1rem;
}

h3 {
    font-size: 1.3rem;
    margin-top: 0.8rem;
}

p {
    margin-bottom: 1rem;
    color: #444;
}

ol {
	margin-left: 30px;
}
button {
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    color: white;
    border: none;
    padding: 10px 16px;
    border-radius: var(--border-radius);
    cursor: pointer;
    margin: 5px 0;
    transition: var(--transition);
    font-weight: 500;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

button:hover {
    opacity: 0.9;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

button:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

button:disabled {
    background: #ccc;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.next-btn {
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
}

.prev-btn {
    background: #6c757d;
}

input[type="file"] {
    margin: 10px 0;
    border: 1px dashed #ccc;
    padding: 8px;
    border-radius: var(--border-radius);
    width: 100%;
}

input[type="file"]:hover {
    border-color: var(--primary-color);
}

input[type="number"] {
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

input[type="range"] {
    height: 5px;
    border-radius: 5px;
    background: #d7dcdf;
    outline: none;
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--primary-color);
    cursor: pointer;
    transition: var(--transition);
}

input[type="range"]::-webkit-slider-thumb:hover {
    background: var(--secondary-color);
}

select {
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background-color: white;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

#lut-preview {
	max-width: 100%;
	height: auto;
}

canvas {
    border: 1px solid #ddd;
    margin: 10px 0;
    max-width: 100%;
    border-radius: 4px;
    background-color: #fcfcfc;
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.05);
}

.container {
    background: var(--card-bg);
    padding: 24px;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    margin-bottom: 24px;
}

.grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
}

.step {
    margin-bottom: 24px;
    padding-bottom: 24px;
    border-bottom: 1px solid #eee;
}

.step:last-child {
    border-bottom: none;
}

.preview {
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: #fafafa;
    padding: 15px;
    border-radius: var(--border-radius);
    margin: 15px 0;
    border: 1px solid #eee;
}

.preview img {
    max-width: 100%;
    margin: 10px 0;
    border-radius: 4px;
}

.controls {
    margin: 20px 0;
    background-color: #f9f9f9;
    padding: 15px;
    border-radius: var(--border-radius);
    border: 1px solid #eee;
}

.slider-container {
    display: flex;
    align-items: center;
    margin: 12px 0;
}

.slider-container label {
    width: 170px;
    font-weight: 500;
    color: #444;
}

input[type="range"] {
    flex: 1;
    margin: 0 12px;
}

.slider-value {
    width: 50px;
    text-align: center;
    font-weight: 500;
    color: var(--primary-color);
}

.color-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
    margin: 15px 0;
}

.color-cell {
    aspect-ratio: 1;
    border: 1px solid #ddd;
    cursor: pointer;
    border-radius: 4px;
    transition: transform 0.2s;
}

.color-cell:hover {
    transform: scale(1.05);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.color-input {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 12px;
    margin: 15px 0;
}

.rgb-input {
    display: flex;
    flex-direction: column;
    background-color: white;
    padding: 16px;
    border-radius: var(--border-radius);
    border: 1px solid #eee;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
}

.rgb-input label {
    margin-bottom: 8px;
    font-weight: 500;
}

.rgb-input input {
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    width: 100%;
}

.chart-controls {
    margin: 10px 0;
    display: flex;
    gap: 10px;
}

.tab-container {
    margin: 24px 0;
}

.tab-buttons {
    display: flex;
    overflow-x: auto;
    border-bottom: 1px solid #ddd;
    scrollbar-width: thin;
    background-color: #f1f1f1;
    border-radius: var(--border-radius) var(--border-radius) 0 0;
    padding: 0 2px;
}

.tab-btn {
    background: none;
    border: none;
    padding: 12px 20px;
    cursor: pointer;
    background-color: transparent;
    color: #666;
    transition: var(--transition);
    font-weight: 500;
    position: relative;
    box-shadow: none;
}

.tab-btn:hover {
    background-color: rgba(74, 111, 165, 0.1);
    color: var(--primary-color);
    box-shadow: none;
}

.tab-btn.active {
    color: var(--primary-color);
    font-weight: 600;
    background-color: white;
    border-radius: var(--border-radius) var(--border-radius) 0 0;
    box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.05);
}

.tab-btn.active::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 3px;
    background-color: var(--primary-color);
}

.tab-content {
    padding: 24px;
    border: 1px solid #ddd;
    border-top: none;
    border-radius: 0 0 var(--border-radius) var(--border-radius);
    background-color: white;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
}

.tab-panel {
    display: none;
    animation: fadeIn 0.3s;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.tab-panel.active {
    display: block;
}

.visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

.log-container {
    background-color: #f8f8f8;
    border: 1px solid #ddd;
    border-radius: var(--border-radius);
    padding: 12px;
    margin: 15px 0;
    max-height: 200px;
    overflow-y: auto;
    font-family: monospace;
    font-size: 0.9rem;
}

.log-entry {
    margin-bottom: 6px;
    padding-bottom: 6px;
    border-bottom: 1px dashed #eee;
}

.info {
    color: #0066cc;
}

.warning {
    color: #cc9900;
}

.error {
    color: #cc0000;
}

.success {
    color: #009900;
}

.progress-container {
    width: 100%;
    height: 12px;
    background-color: #f1f1f1;
    border-radius: 50px;
    margin: 15px 0;
    overflow: hidden;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
}

.progress-bar {
    height: 100%;
    width: 0;
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    transition: width 0.3s ease;
    border-radius: 50px;
}

#selected-color-preview {
    margin: 10px auto;
    width: 120px;
    height: 120px;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

#lut-download-container {
    margin-top: 15px;
    display: flex;
    justify-content: center;
}

#lut-download-container button {
    min-width: 180px;
}

@media (max-width: 768px) {
    .grid {
        grid-template-columns: 1fr;
    }
    
    .slider-container {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .slider-container label {
        width: 100%;
        margin-bottom: 8px;
    }
    
    input[type="range"] {
        width: 100%;
        margin: 8px 0;
    }
    
    .tab-buttons {
        flex-wrap: nowrap;
        overflow-x: auto;
        white-space: nowrap;
    }
    
    .tab-btn {
        padding: 10px 15px;
        font-size: 0.9rem;
    }
}
    </style>
</head>
<body>
    <div class="container">
        <h1>Browser-based LUT Maker</h1>
        <p>Create your own custom LUTs for OBS or other applications using color cards.</p>
		<div class="info-section" style="margin-top: 10px; font-size: 0.9rem; color: #666; border-top: 1px solid #eee; padding-top: 10px;">
			<p>Created by Steve Seguin. 
			   <a href="https://github.com/steveseguin/LUT-maker" target="_blank">View on GitHub</a> | 
			   <a href="https://www.youtube.com/watch?v=pu9IpbfckDo" target="_blank">Watch Tutorial Video</a>
			</p>
		</div>
    </div>
    
    <div class="tab-container">
        <div class="tab-buttons">
            <button class="tab-btn active" data-tab="setup">1. Setup</button>
            <button class="tab-btn" data-tab="reference" disabled>2. Reference Colors</button>
            <button class="tab-btn" data-tab="colorcard" disabled>3. Color Card</button>
            <button class="tab-btn" data-tab="process" disabled>4. Process</button>
            <button class="tab-btn" data-tab="test" disabled>5. Test & Adjust</button>
            <button class="tab-btn" data-tab="export" disabled>6. Export LUT</button>
        </div>
        
        <div class="tab-content">
            <!-- Tab 1: Setup -->
            <div class="tab-panel active" id="setup-tab">
                <div class="step">
                    <h2>Welcome to the LUT Maker</h2>
                    <p>This tool helps you create custom Look-Up Tables (LUTs) for color correction in applications like OBS, based on a photo of a color reference chart.</p>
                    <p>The process involves these steps:</p>
                    <ol>
                        <li>Setup the color grid configuration</li>
                        <li>Define reference colors for your color chart</li>
                        <li>Upload a photo of your color chart</li>
                        <li>Process and create the transformation</li>
                        <li>Test and adjust the results</li>
                        <li>Export the final LUT file</li>
                    </ol>
                </div>
                
                <div class="step">
                    <h3>Color Grid Configuration</h3>
                    <p>First, define the layout of your color reference chart:</p>
                    <div class="controls">
                        <div class="slider-container">
                            <label for="rows-slider">Number of Rows:</label>
                            <input type="range" id="rows-slider" min="1" max="8" value="3" class="slider">
                            <span id="rows-value" class="slider-value">3</span>
                        </div>
                        <div class="slider-container">
                            <label for="columns-slider">Number of Columns:</label>
                            <input type="range" id="columns-slider" min="1" max="8" value="3" class="slider">
                            <span id="columns-value" class="slider-value">3</span>
                        </div>
                        <div class="slider-container">
                            <label for="border-slider">Cell Border Percentage:</label>
                            <input type="range" id="border-slider" min="0" max="50" value="25" class="slider">
                            <span id="border-value" class="slider-value">25%</span>
                        </div>
                    </div>
                    <p>This configuration defines how your color chart is laid out and how much border to ignore when analyzing each color block.</p>
					<div class="step">
					<h3>Templates</h3>
					<div class="controls">
						<h4>Color Presets</h4>
						<div style="display: flex; gap: 10px; margin: 10px 0;">
							<select id="color-preset-select" style="flex-grow: 1;">
								<option value="">-- Select a Preset --</option>
								<option value="datacolor24">Datacolor SpyderCHECKR 24</option>
								<option value="datacolor48">Datacolor SpyderCHECKR 48 (Full)</option>
							</select>
							<button id="apply-preset-button">Apply Preset</button>
						</div>
						<h4>Save/Load Template</h4>
						<div style="display: flex; gap: 10px; margin: 10px 0;">
							<button id="save-template-button">Save Template</button>
							<button id="load-template-button">Load Saved Template</button>
						</div>
						<p style="margin-top: 8px; font-size: 0.9em; color: #666;">Templates are saved to your browser's local storage.</p>
					</div>
				</div>
                    <button id="setup-next" class="next-btn">Continue to Reference Colors</button>
                </div>
            </div>
            
            <!-- Tab 2: Reference Colors -->
            <div class="tab-panel" id="reference-tab">
                <div class="step">
                    <h2>Reference Colors</h2>
                    <p>Define the RGB values for each color in your reference chart. These are the "correct" colors that your camera should capture.</p>
                    <p>At minimum, you should include white, gray, and black. Adding other colors will improve the results.</p>
                    
                    <div class="grid">
                        <div>
                            <h3>Color Grid Preview</h3>
                            <div id="reference-grid-container">
                                <div class="color-grid" id="reference-grid"></div>
                            </div>
                            <div class="controls">
                                <button id="reset-colors">Reset Colors</button>
                                <button id="use-example">Use Example Colors</button>
                            </div>
                        </div>
                        
                        <div>
                            <h3>Selected Color</h3>
                            <div id="selected-color-preview" style="width: 100px; height: 100px; border: 1px solid #ddd; margin: 10px 0;"></div>
                            <div id="selected-color-inputs" class="rgb-input">
                                <label for="red-input">Red (0-255):</label>
                                <input type="number" id="red-input" min="0" max="255" value="128">
                                <label for="green-input">Green (0-255):</label>
                                <input type="number" id="green-input" min="0" max="255" value="128">
                                <label for="blue-input">Blue (0-255):</label>
                                <input type="number" id="blue-input" min="0" max="255" value="128">
                                <button id="update-color" style="margin-top: 10px;">Update Color</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button id="reference-prev" class="prev-btn">Back</button>
                        <button id="reference-next" class="next-btn">Continue to Color Card</button>
                    </div>
                </div>
            </div>
            
            <!-- Tab 3: Color Card Photo -->
            <div class="tab-panel" id="colorcard-tab">
                <div class="step">
                    <h2>Upload Color Card Photo</h2>
                    <p>Upload a photo of your color reference chart taken with your camera under the lighting conditions you wish to create your LUT for.</p>
                    <p>Make sure the photo is well-lit and the entire color chart is visible and not distorted.</p>
                    
                    <div class="controls">
                        <input type="file" id="colorcard-upload" accept="image/*">
                        <button id="use-demo-image">Use Demo Image</button>
                    </div>
                    
                    <div class="preview">
                        <h3>Preview</h3>
                        <canvas id="colorcard-preview"></canvas>
                        <div id="colorcard-info"></div>
                    </div>
                    
                    <div class="controls">
                        <button id="colorcard-prev" class="prev-btn">Back</button>
                        <button id="colorcard-next" class="next-btn" disabled>Continue to Processing</button>
                    </div>
                </div>
            </div>
            
            <!-- Tab 4: Process -->
            <div class="tab-panel" id="process-tab">
                <div class="step">
                    <h2>Process Color Transformation</h2>
                    <p>Extract colors from your photo and create the color transformation.</p>
                    
                    <div class="grid">
                        <div>
                            <h3>Target Colors</h3>
                            <div class="color-grid" id="target-grid"></div>
                        </div>
                        <div>
                            <h3>Captured Colors</h3>
                            <div class="color-grid" id="captured-grid"></div>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <div class="slider-container">
                            <label for="polynomial-slider">Polynomial Degree:</label>
                            <input type="range" id="polynomial-slider" min="1" max="3" value="1" class="slider">
                            <span id="polynomial-value" class="slider-value">1</span>
                        </div>
						<div class="slider-container">
							<label for="advanced-processing-toggle">Use Advanced Color Processing:</label>
							<input type="checkbox" id="advanced-processing-toggle" checked>
							<small>Enables cross-channel influence and better rolloff curves</small>
						</div>
                        <button id="process-button">Process Color Transformation</button>
                    </div>
					

                    
                    <div class="log-container" id="process-log"></div>
                    
                    <div class="progress-container" id="process-progress-container">
                        <div class="progress-bar" id="process-progress-bar"></div>
                    </div>
                    
                    <div class="controls">
                        <button id="process-prev" class="prev-btn">Back</button>
                        <button id="process-next" class="next-btn" disabled>Continue to Testing</button>
                    </div>
                </div>
            </div>
            
            <!-- Tab 5: Test & Adjust -->
            <div class="tab-panel" id="test-tab">
                <div class="step">
                    <h2>Test and Adjust Results</h2>
                    <p>Upload a test image to see how the color transformation affects it, and make adjustments if needed.</p>
                    
                    <div class="controls">
                        <input type="file" id="test-upload" accept="image/*">
                        <button id="use-demo-test">Use Demo Test Image</button>
                    </div>
                    
                    <div class="preview">
                        <h3>Test Image Preview</h3>
                        <div class="grid">
                            <div>
                                <h4>Original</h4>
                                <canvas id="test-original"></canvas>
                            </div>
                            <div>
                                <h4>Processed</h4>
                                <canvas id="test-processed"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <div class="slider-container">
                            <label for="brightness-slider">Brightness Adjustment:</label>
                            <input type="range" id="brightness-slider" min="-50" max="50" value="0" class="slider">
                            <span id="brightness-value" class="slider-value">0</span>
                        </div>
                        <div class="slider-container">
                            <label for="gamma-slider">Gamma Adjustment:</label>
                            <input type="range" id="gamma-slider" min="0.5" max="2.5" value="1" step="0.1" class="slider">
                            <span id="gamma-value" class="slider-value">1.0</span>
                        </div>
                        <button id="apply-adjustments">Apply Adjustments</button>
                    </div>
                    
                    <div class="controls">
                        <button id="test-prev" class="prev-btn">Back</button>
                        <button id="test-next" class="next-btn" disabled>Continue to Export</button>
                    </div>
                </div>
            </div>
            
            <!-- Tab 6: Export LUT -->
            <div class="tab-panel" id="export-tab">
                <div class="step">
                    <h2>Export LUT</h2>
                    <p>Generate and download your custom LUT file.</p>
                    
                    <div class="controls">
                        <div class="slider-container">
                            <label for="lut-size-slider">LUT Size:</label>
                            <input type="range" id="lut-size-slider" min="16" max="64" value="32" step="16" class="slider">
                            <span id="lut-size-value" class="slider-value">32</span>
                        </div>
                        <div class="slider-container">
                            <label for="lut-format">LUT Format:</label>
                            <select id="lut-format">
                                <option value="png">PNG (OBS compatible)</option>
                                <option value="cube">CUBE</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button id="generate-lut">Generate LUT</button>
                    </div>
                    
                    <div class="progress-container" id="export-progress-container">
                        <div class="progress-bar" id="export-progress-bar"></div>
                    </div>
                    
                    <div class="preview">
                        <h3>LUT Preview</h3>
                        <canvas id="lut-preview"></canvas>
                        <div id="lut-download-container" style="display: none;">
                            <button id="download-lut">Download LUT</button>
                        </div>
                    </div>
                    
                    <div class="controls">
                        <button id="export-prev" class="prev-btn">Back</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Main app state
        const state = {
            rows: 3,
            columns: 3,
            cellBorderPercentage: 25,
            referenceColors: [],
            capturedColors: [],
            selectedCellIndex: null,
            colorCardImage: null,
            testImage: null,
            processedTestImage: null,
            polynomialDegree: 1,
            brightnessAdjustment: 0,
            gammaValue: 1.0,
            lutSize: 32,
            lutFormat: 'png',
            transformationCoefficients: {
                red: null,
                green: null,
                blue: null
            },
            lutImage: null,
            cubeData: null,
			useAdvancedProcessing: true,
			transformationModels: {
				basic: {
					red: null,
					green: null,
					blue: null
				},
				multivariate: {
					red: null,
					green: null,
					blue: null
				}
			},
			gammaCurves: null
        };
        
		document.addEventListener('DOMContentLoaded', function() {
		  // Call the original initialization
		  initializeSliders();
		  initializeTabs();
		  initializeReferenceGrid();
		  initializeColorCardUpload();
		  initializeTestImageUpload();
		  initializeProcessing();
		  initializeExport();
		  initializeEventListeners();
		  initializeTemplateControls();
		  
		  // Try to load saved template on startup
		  setTimeout(() => {
			try {
			  if (localStorage.getItem('lutMakerTemplate')) {
				loadTemplate();
			  }
			} catch (e) {
			  // Silently fail if local storage is not available
			}
		  }, 500);
		  
		  // Log welcome message
		  logMessage('Welcome to the Browser-based LUT Maker!', 'info');
		});
        
        // Initialize sliders and inputs
        function initializeSliders() {
            // Rows slider
            const rowsSlider = document.getElementById('rows-slider');
            const rowsValue = document.getElementById('rows-value');
            rowsSlider.addEventListener('input', function() {
                state.rows = parseInt(this.value);
                rowsValue.textContent = state.rows;
                initializeReferenceGrid();
            });
            
            // Columns slider
            const columnsSlider = document.getElementById('columns-slider');
            const columnsValue = document.getElementById('columns-value');
            columnsSlider.addEventListener('input', function() {
                state.columns = parseInt(this.value);
                columnsValue.textContent = state.columns;
                initializeReferenceGrid();
            });
            
            // Cell border slider
            const borderSlider = document.getElementById('border-slider');
            const borderValue = document.getElementById('border-value');
            borderSlider.addEventListener('input', function() {
                state.cellBorderPercentage = parseInt(this.value);
                borderValue.textContent = state.cellBorderPercentage + '%';
            });
            
            // Polynomial degree slider
            const polySlider = document.getElementById('polynomial-slider');
            const polyValue = document.getElementById('polynomial-value');
            polySlider.addEventListener('input', function() {
                state.polynomialDegree = parseInt(this.value);
                polyValue.textContent = state.polynomialDegree;
            });
            
            // Brightness slider
            const brightnessSlider = document.getElementById('brightness-slider');
            const brightnessValue = document.getElementById('brightness-value');
            brightnessSlider.addEventListener('input', function() {
                state.brightnessAdjustment = parseInt(this.value);
                brightnessValue.textContent = state.brightnessAdjustment;
            });
            
            // Gamma slider
            const gammaSlider = document.getElementById('gamma-slider');
            const gammaValue = document.getElementById('gamma-value');
            gammaSlider.addEventListener('input', function() {
                state.gammaValue = parseFloat(this.value);
                gammaValue.textContent = state.gammaValue.toFixed(1);
            });
            
            // LUT size slider
            const lutSizeSlider = document.getElementById('lut-size-slider');
            const lutSizeValue = document.getElementById('lut-size-value');
            lutSizeSlider.addEventListener('input', function() {
                state.lutSize = parseInt(this.value);
                lutSizeValue.textContent = state.lutSize;
            });
            
            // LUT format select
            const lutFormat = document.getElementById('lut-format');
            lutFormat.addEventListener('change', function() {
                state.lutFormat = this.value;
            });
        }
        
        // Helper function to log messages
        function logMessage(message, type = 'info') {
            const logContainer = document.getElementById('process-log');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = message;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // Update progress bar
        function updateProgress(containerId, value) {
            const progressBar = document.getElementById(`${containerId}-progress-bar`);
            progressBar.style.width = `${value}%`;
        }
        
        // RGB to Hex conversion
        function rgbToHex(rgb) {
            return `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        }
        
        // Update the captured colors grid
        function updateCapturedColorsGrid() {
            const gridContainer = document.getElementById('captured-grid');
            gridContainer.innerHTML = '';
            gridContainer.style.gridTemplateColumns = `repeat(${state.columns}, 1fr)`;
            
            for (let i = 0; i < state.capturedColors.length; i++) {
                const cell = document.createElement('div');
                cell.className = 'color-cell';
                cell.style.backgroundColor = rgbToHex(state.capturedColors[i]);
                gridContainer.appendChild(cell);
            }
            
            // Also update target grid
            const targetGrid = document.getElementById('target-grid');
            targetGrid.innerHTML = '';
            targetGrid.style.gridTemplateColumns = `repeat(${state.columns}, 1fr)`;
            
            for (let i = 0; i < state.referenceColors.length; i++) {
                const cell = document.createElement('div');
                cell.className = 'color-cell';
                cell.style.backgroundColor = rgbToHex(state.referenceColors[i]);
                targetGrid.appendChild(cell);
            }
        }
        
        // Initialize tabs
        function initializeTabs() {
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabPanels = document.querySelectorAll('.tab-panel');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    
                    // Only allow clicking on enabled tabs
                    if (this.disabled) return;
                    
                    // Deactivate all tabs
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabPanels.forEach(panel => panel.classList.remove('active'));
                    
                    // Activate the clicked tab
                    this.classList.add('active');
                    document.getElementById(`${tabId}-tab`).classList.add('active');
                });
            });
            
            // Next button handlers
            document.getElementById('setup-next').addEventListener('click', function() {
                enableTab('reference');
                activateTab('reference');
            });
            
            document.getElementById('reference-next').addEventListener('click', function() {
                enableTab('colorcard');
                activateTab('colorcard');
            });
            
            document.getElementById('colorcard-next').addEventListener('click', function() {
                enableTab('process');
                activateTab('process');
            });
            
            document.getElementById('process-next').addEventListener('click', function() {
                enableTab('test');
                activateTab('test');
            });
            
            document.getElementById('test-next').addEventListener('click', function() {
                enableTab('export');
                activateTab('export');
            });
            
            // Previous button handlers
            document.getElementById('reference-prev').addEventListener('click', function() {
                activateTab('setup');
            });
            
            document.getElementById('colorcard-prev').addEventListener('click', function() {
                activateTab('reference');
            });
            
            document.getElementById('process-prev').addEventListener('click', function() {
                activateTab('colorcard');
            });
            
            document.getElementById('test-prev').addEventListener('click', function() {
                activateTab('process');
            });
            
            document.getElementById('export-prev').addEventListener('click', function() {
                activateTab('test');
            });
        }
        
        // Enable a tab
        function enableTab(tabId) {
            const tabButton = document.querySelector(`.tab-btn[data-tab="${tabId}"]`);
            if (tabButton) {
                tabButton.disabled = false;
            }
        }
        
        // Activate a tab
        function activateTab(tabId) {
            const tabButton = document.querySelector(`.tab-btn[data-tab="${tabId}"]`);
            if (tabButton && !tabButton.disabled) {
                tabButton.click();
            }
        }
        
        // Initialize reference color grid
        function initializeReferenceGrid() {
            const gridContainer = document.getElementById('reference-grid');
            gridContainer.innerHTML = '';
            gridContainer.style.gridTemplateColumns = `repeat(${state.columns}, 1fr)`;
            
            // Initialize with default colors if not already set
            if (state.referenceColors.length !== state.rows * state.columns) {
                state.referenceColors = Array(state.rows * state.columns).fill().map(() => [128, 128, 128]);
            }
            
            // Create color cells
            for (let i = 0; i < state.rows * state.columns; i++) {
                const cell = document.createElement('div');
                cell.className = 'color-cell';
                cell.dataset.index = i;
                cell.style.backgroundColor = rgbToHex(state.referenceColors[i]);
                
                cell.addEventListener('click', function() {
                    selectCell(parseInt(this.dataset.index));
                });
                
                gridContainer.appendChild(cell);
            }
        }
        
        // Select a color cell
        function selectCell(index) {
            state.selectedCellIndex = index;
            
            // Update all cell borders
            const cells = document.querySelectorAll('.color-cell');
            cells.forEach(cell => {
                cell.style.border = '1px solid #ddd';
            });
            
            // Highlight selected cell
            const selectedCell = document.querySelector(`.color-cell[data-index="${index}"]`);
            if (selectedCell) {
                selectedCell.style.border = '3px solid #000';
            }
            
            // Update color inputs
            const [r, g, b] = state.referenceColors[index];
            document.getElementById('red-input').value = r;
            document.getElementById('green-input').value = g;
            document.getElementById('blue-input').value = b;
            
            // Update color preview
            const colorPreview = document.getElementById('selected-color-preview');
            colorPreview.style.backgroundColor = rgbToHex(state.referenceColors[index]);
        }
        
       function initializeColorCardUpload() {
			const fileInput = document.getElementById('colorcard-upload');
			fileInput.addEventListener('change', function(event) {
			  const file = event.target.files[0];
			  if (file) {
				loadImage(file, 'colorcard'); // Fixed: using 'colorcard' instead of undefined 'type'
				logMessage(`Color card image loaded successfully`, 'success');
			  }
			});
			
			// Add demo image functionality properly
			const demoButton = document.getElementById('use-demo-image');
			if (demoButton) {
			  demoButton.addEventListener('click', function() {
				loadDemoImage('colorcard');
			  });
			}
		  };
        // Extract colors from the color card image
        function extractColorsFromImage(img) {
            logMessage('Extracting colors from image...', 'info');
            
            // Create a temporary canvas to process the image
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            tempCtx.drawImage(img, 0, 0);
            
            // Extract colors from each cell
            state.capturedColors = [];
            
            for (let row = 0; row < state.rows; row++) {
                for (let col = 0; col < state.columns; col++) {
                    // Calculate cell boundaries with border percentage
                    const cellWidth = img.width / state.columns;
                    const cellHeight = img.height / state.rows;
                    
                    const borderX = (state.cellBorderPercentage / 100) * cellWidth / 2;
                    const borderY = (state.cellBorderPercentage / 100) * cellHeight / 2;
                    
                    const x = Math.floor(col * cellWidth + borderX);
                    const y = Math.floor(row * cellHeight + borderY);
                    const width = Math.floor(cellWidth - 2 * borderX);
                    const height = Math.floor(cellHeight - 2 * borderY);
                    
                    // Get the cell data
                    const cellData = tempCtx.getImageData(x, y, width, height);
                    
                    // Calculate color histograms to find peak values
                    const rHistogram = new Array(256).fill(0);
                    const gHistogram = new Array(256).fill(0);
                    const bHistogram = new Array(256).fill(0);
                    
                    for (let i = 0; i < cellData.data.length; i += 4) {
                        rHistogram[cellData.data[i]]++;
                        gHistogram[cellData.data[i + 1]]++;
                        bHistogram[cellData.data[i + 2]]++;
                    }
                    
                    // Find peak values
                    const r = rHistogram.indexOf(Math.max(...rHistogram));
                    const g = gHistogram.indexOf(Math.max(...gHistogram));
                    const b = bHistogram.indexOf(Math.max(...bHistogram));
                    
                    state.capturedColors.push([r, g, b]);
                }
            }
            
            // Update the captured colors grid
            updateCapturedColorsGrid();
            
            logMessage('Color extraction complete', 'success');
            
            // Enable the next button
            document.getElementById('colorcard-next').disabled = false;
        }
        
        // Load an image file
		function loadImage(file, type) {
			const reader = new FileReader();
			
			reader.onload = function(e) {
				const img = new Image();
				img.onload = function() {
					if (type === 'colorcard') {
						state.colorCardImage = img;
						displayColorCardImage(img);
					} else if (type === 'test') {
						state.testImage = img;
						displayTestImage(img);
						document.getElementById('test-next').disabled = false;
					}
				};
				img.src = e.target.result;
			};
			
			reader.readAsDataURL(file);
		}
        
        // Initialize the processing functionality
        function initializeProcessing() {
            // Process button
            document.getElementById('process-button').addEventListener('click', function() {
                processColorTransformation();
            });
            
            // Update selected color
            document.getElementById('update-color').addEventListener('click', function() {
                if (state.selectedCellIndex !== null) {
                    const r = parseInt(document.getElementById('red-input').value);
                    const g = parseInt(document.getElementById('green-input').value);
                    const b = parseInt(document.getElementById('blue-input').value);
                    
                    state.referenceColors[state.selectedCellIndex] = [
                        isNaN(r) ? 0 : Math.min(255, Math.max(0, r)),
                        isNaN(g) ? 0 : Math.min(255, Math.max(0, g)),
                        isNaN(b) ? 0 : Math.min(255, Math.max(0, b))
                    ];
                    
                    // Update grid
                    const cell = document.querySelector(`.color-cell[data-index="${state.selectedCellIndex}"]`);
                    if (cell) {
                        cell.style.backgroundColor = rgbToHex(state.referenceColors[state.selectedCellIndex]);
                    }
                    
                    // Update preview
                    const colorPreview = document.getElementById('selected-color-preview');
                    colorPreview.style.backgroundColor = rgbToHex(state.referenceColors[state.selectedCellIndex]);
                }
            });
            
            // Reset colors
            document.getElementById('reset-colors').addEventListener('click', function() {
                state.referenceColors = Array(state.rows * state.columns).fill().map(() => [128, 128, 128]);
                initializeReferenceGrid();
            });
            
            // Use example colors (color chart from the original code)
            document.getElementById('use-example').addEventListener('click', function() {
                const exampleColors = [
                    [147, 163, 96], [154, 64, 73], [0, 166, 153],
                    [61, 65, 93], [96, 102, 102], [247, 185, 48],
                    [62, 63, 64], [245, 243, 236], [138, 83, 129]
                ];
                
                // Only use as many colors as there are cells
                state.referenceColors = [];
                for (let i = 0; i < state.rows * state.columns; i++) {
                    if (i < exampleColors.length) {
                        state.referenceColors.push(exampleColors[i]);
                    } else {
                        state.referenceColors.push([128, 128, 128]);
                    }
                }
                
                initializeReferenceGrid();
                logMessage('Example colors loaded', 'success');
            });
        }
		
		const colorPresets = {
		  datacolor24: {
			name: "Datacolor SpyderCHECKR 24",
			rows: 4,
			columns: 6,
			colors: [
			  [98, 187, 166], [126, 125, 174], [82, 106, 60], [87, 120, 155], [197, 145, 125], [112, 76, 60],
			  [222, 118, 32], [58, 89, 160], [195, 79, 95], [83, 58, 106], [157, 188, 54], [238, 158, 25],
			  [0, 127, 159], [192, 75, 145], [245, 205, 0], [186, 26, 51], [57, 146, 64], [25, 55, 135],
			  [249, 242, 238], [202, 198, 195], [161, 157, 154], [122, 118, 116], [80, 80, 78], [43, 41, 43]
			]
		  },
		  datacolor48: {
			name: "Datacolor SpyderCHECKR 48",
			rows: 6,
			columns: 8,
			colors: [
			  [115, 82, 68], [194, 150, 130], [98, 122, 157], [87, 108, 67], [133, 128, 177], [103, 189, 170],
			  [214, 126, 44], [80, 91, 166], [193, 90, 99], [94, 60, 108], [157, 188, 64], [224, 163, 46],
			  [56, 61, 150], [70, 148, 73], [175, 54, 60], [231, 199, 31], [187, 86, 149], [8, 133, 161],
			  [243, 243, 242], [200, 200, 200], [160, 160, 160], [122, 122, 121], [85, 85, 85], [52, 52, 52],
			  [51, 43, 41], [95, 84, 79], [132, 121, 115], [166, 156, 148], [199, 189, 182], [241, 233, 228],
			  [108, 60, 45], [159, 92, 64], [210, 129, 83], [222, 165, 117], [235, 198, 146], [249, 234, 189],
			  [45, 61, 36], [52, 95, 45], [65, 131, 57], [129, 167, 83], [177, 201, 111], [231, 231, 152],
			  [51, 63, 116], [47, 100, 158], [65, 137, 194], [117, 175, 211], [157, 201, 231], [199, 228, 243],
			  [69, 38, 102], [106, 61, 152], [142, 85, 193], [176, 126, 219], [205, 164, 231], [230, 196, 243],
			  [84, 48, 37], [136, 68, 47], [186, 95, 58], [209, 150, 58], [239, 192, 58], [242, 232, 72]
			]
		  },
		  // Can add other presets here
		};
		
		// Add template saving/loading functionality
		function saveTemplate() {
		  const template = {
			rows: state.rows,
			columns: state.columns,
			cellBorderPercentage: state.cellBorderPercentage,
			referenceColors: state.referenceColors
		  };
		  
		  try {
			localStorage.setItem('lutMakerTemplate', JSON.stringify(template));
			logMessage('Template saved to browser storage', 'success');
		  } catch (error) {
			logMessage('Failed to save template: ' + error.message, 'error');
		  }
		}

		function loadTemplate() {
		  try {
			const savedTemplate = localStorage.getItem('lutMakerTemplate');
			if (savedTemplate) {
			  const template = JSON.parse(savedTemplate);
			  
			  // Update state
			  state.rows = template.rows;
			  state.columns = template.columns;
			  state.cellBorderPercentage = template.cellBorderPercentage;
			  state.referenceColors = template.referenceColors;
			  
			  // Update UI
			  document.getElementById('rows-slider').value = state.rows;
			  document.getElementById('rows-value').textContent = state.rows;
			  
			  document.getElementById('columns-slider').value = state.columns;
			  document.getElementById('columns-value').textContent = state.columns;
			  
			  document.getElementById('border-slider').value = state.cellBorderPercentage;
			  document.getElementById('border-value').textContent = state.cellBorderPercentage + '%';
			  
			  // Refresh the grid
			  initializeReferenceGrid();
			  
			  logMessage('Template loaded from browser storage', 'success');
			} else {
			  logMessage('No saved template found', 'warning');
			}
		  } catch (error) {
			logMessage('Failed to load template: ' + error.message, 'error');
		  }
		}

		// Apply preset colors
		function applyPreset(presetName) {
		  const preset = colorPresets[presetName];
		  if (!preset) {
			logMessage(`Preset "${presetName}" not found`, 'error');
			return;
		  }
		  
		  // Update grid dimensions
		  state.rows = preset.rows;
		  state.columns = preset.columns;
		  document.getElementById('rows-slider').value = state.rows;
		  document.getElementById('rows-value').textContent = state.rows;
		  document.getElementById('columns-slider').value = state.columns;
		  document.getElementById('columns-value').textContent = state.columns;
		  
		  // Update reference colors
		  state.referenceColors = [...preset.colors];
		  
		  // Refresh the grid
		  initializeReferenceGrid();
		  
		  logMessage(`Applied "${preset.name}" color preset`, 'success');
		}

		// Initialize presets dropdown and template UI
		function initializeTemplateControls() {
		  // Add event listeners for template buttons
		  document.getElementById('apply-preset-button').addEventListener('click', function() {
			const select = document.getElementById('color-preset-select');
			const selectedPreset = select.value;
			if (selectedPreset) {
			  applyPreset(selectedPreset);
			} else {
			  logMessage('Please select a preset first', 'warning');
			}
		  });
		  
		  document.getElementById('save-template-button').addEventListener('click', saveTemplate);
		  document.getElementById('load-template-button').addEventListener('click', loadTemplate);
		}
		
        
        // Process the color transformation
        function processColorTransformation() {
            logMessage('Starting color transformation processing...', 'info');
            
            if (state.capturedColors.length === 0) {
                logMessage('No captured colors found. Please upload a color card image first.', 'error');
                return;
            }
            
            if (state.referenceColors.length === 0) {
                logMessage('No reference colors defined. Please set up your reference colors first.', 'error');
                return;
            }
            
            // Polynomial regression for each channel (R, G, B)
            try {
                // Process red channel
                updateProgress('process', 10);
                state.transformationCoefficients.red = polynomialRegression(
                    state.capturedColors.map(color => color[0]),
                    state.referenceColors.map(color => color[0]),
                    state.polynomialDegree
                );
                logMessage('Red channel transformation calculated', 'info');
                
                // Process green channel
                updateProgress('process', 40);
                state.transformationCoefficients.green = polynomialRegression(
                    state.capturedColors.map(color => color[1]),
                    state.referenceColors.map(color => color[1]),
                    state.polynomialDegree
                );
                logMessage('Green channel transformation calculated', 'info');
                
                // Process blue channel
                updateProgress('process', 70);
                state.transformationCoefficients.blue = polynomialRegression(
                    state.capturedColors.map(color => color[2]),
                    state.referenceColors.map(color => color[2]),
                    state.polynomialDegree
                );
                logMessage('Blue channel transformation calculated', 'info');
                
                updateProgress('process', 100);
                logMessage('Color transformation processing complete!', 'success');
                
                // Enable next step
                document.getElementById('process-next').disabled = false;
                
                // If a test image is already loaded, process it with the new coefficients
                if (state.testImage) {
                    processTestImage();
                }
            } catch (error) {
                logMessage(`Error processing color transformation: ${error}`, 'error');
            }
        }
        
        // Polynomial regression function
        function polynomialRegression(x, y, degree) {
            if (x.length !== y.length) {
                throw new Error('Input arrays must have the same length');
            }
            
            const n = x.length;
            const coefficients = new Array(degree + 1).fill(0);
            
            // For simple linear regression (degree 1)
            if (degree === 1) {
                let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                
                for (let i = 0; i < n; i++) {
                    sumX += x[i];
                    sumY += y[i];
                    sumXY += x[i] * y[i];
                    sumX2 += x[i] * x[i];
                }
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;
                
                coefficients[0] = intercept;
                coefficients[1] = slope;
            } else {
                // For higher degree polynomials we need to solve a system of linear equations
                // Using normal equations: (X^T * X) * beta = X^T * y
                
                // Create design matrix X
                const X = [];
                for (let i = 0; i < n; i++) {
                    const row = [];
                    for (let j = 0; j <= degree; j++) {
                        row.push(Math.pow(x[i], j));
                    }
                    X.push(row);
                }
                
                // Calculate X^T * X
                const XtX = [];
                for (let i = 0; i <= degree; i++) {
                    XtX[i] = [];
                    for (let j = 0; j <= degree; j++) {
                        let sum = 0;
                        for (let k = 0; k < n; k++) {
                            sum += X[k][i] * X[k][j];
                        }
                        XtX[i][j] = sum;
                    }
                }
                
                // Calculate X^T * y
                const Xty = [];
                for (let i = 0; i <= degree; i++) {
                    let sum = 0;
                    for (let k = 0; k < n; k++) {
                        sum += X[k][i] * y[k];
                    }
                    Xty[i] = sum;
                }
                
                // Solve system of linear equations using Gaussian elimination
                // Augmented matrix [XtX|Xty]
                const augmentedMatrix = [];
                for (let i = 0; i <= degree; i++) {
                    augmentedMatrix[i] = [...XtX[i], Xty[i]];
                }
                
                // Gaussian elimination
                for (let i = 0; i <= degree; i++) {
                    // Find pivot
                    let maxRow = i;
                    for (let j = i + 1; j <= degree; j++) {
                        if (Math.abs(augmentedMatrix[j][i]) > Math.abs(augmentedMatrix[maxRow][i])) {
                            maxRow = j;
                        }
                    }
                    
                    // Swap rows
                    if (maxRow !== i) {
                        [augmentedMatrix[i], augmentedMatrix[maxRow]] = [augmentedMatrix[maxRow], augmentedMatrix[i]];
                    }
                    
                    // Eliminate below
                    for (let j = i + 1; j <= degree; j++) {
                        const factor = augmentedMatrix[j][i] / augmentedMatrix[i][i];
                        for (let k = i; k <= degree + 1; k++) {
                            augmentedMatrix[j][k] -= factor * augmentedMatrix[i][k];
                        }
                    }
                }
                
                // Back substitution
                for (let i = degree; i >= 0; i--) {
                    let sum = 0;
                    for (let j = i + 1; j <= degree; j++) {
                        sum += augmentedMatrix[i][j] * coefficients[j];
                    }
                    coefficients[i] = (augmentedMatrix[i][degree + 1] - sum) / augmentedMatrix[i][i];
                }
            }
            
            return coefficients;
        }
        
        // Apply polynomial transformation to a value
        function applyPolynomial(value, coefficients) {
            let result = 0;
            for (let i = 0; i < coefficients.length; i++) {
                result += coefficients[i] * Math.pow(value, i);
            }
            return result;
        }
        
        // Process the test image with the current transformation
        function processTestImage() {
            if (!state.testImage || !state.transformationCoefficients.red) {
                return;
            }
            
            logMessage('Processing test image...', 'info');
            
            // Create temporary canvas for processing
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = state.testImage.width;
            tempCanvas.height = state.testImage.height;
            tempCtx.drawImage(state.testImage, 0, 0);
            
            // Get image data
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            // Create gamma curves
            const gammaValue = state.gammaValue;
            const gammaLookup = new Array(256);
            for (let i = 0; i < 256; i++) {
                gammaLookup[i] = Math.min(255, Math.max(0, Math.pow(i / 255, 1 / gammaValue) * 255));
            }
            
            // Process each pixel
            for (let i = 0; i < data.length; i += 4) {
                // Apply color transformation
                let r = applyPolynomial(data[i], state.transformationCoefficients.red);
                let g = applyPolynomial(data[i + 1], state.transformationCoefficients.green);
                let b = applyPolynomial(data[i + 2], state.transformationCoefficients.blue);
                
                // Apply brightness adjustment
                r += state.brightnessAdjustment;
                g += state.brightnessAdjustment;
                b += state.brightnessAdjustment;
                
                // Apply gamma correction
                r = gammaLookup[Math.min(255, Math.max(0, Math.round(r)))];
                g = gammaLookup[Math.min(255, Math.max(0, Math.round(g)))];
                b = gammaLookup[Math.min(255, Math.max(0, Math.round(b)))];
                
                // Set the data
                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
            }
            
            // Put the image data back
            tempCtx.putImageData(imageData, 0, 0);
            
            // Display the processed image
            const processedCanvas = document.getElementById('test-processed');
            const processedCtx = processedCanvas.getContext('2d');
            
            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
            processedCtx.drawImage(tempCanvas, 0, 0, processedCanvas.width, processedCanvas.height);
            
            logMessage('Test image processing complete', 'success');
        }
        
        // Initialize export functionality
        function initializeExport() {
            document.getElementById('generate-lut').addEventListener('click', function() {
                generateLUT();
            });
            
            document.getElementById('download-lut').addEventListener('click', function() {
                downloadLUT();
            });
        }
		
		function generateLUT() {
			if (!state.transformationCoefficients.red) {
				logMessage('No color transformation available. Please process colors first.', 'error');
				return;
			}

			logMessage('Generating LUT...', 'info');
			updateProgress('export', 0);

			const lutCanvas = document.getElementById('lut-preview');
			const lutCtx = lutCanvas.getContext('2d');

			const useAdvancedProcessing = state.useAdvancedProcessing &&
				state.transformationModels &&
				state.transformationModels.multivariate &&
				state.transformationModels.multivariate.red;

			const gammaCurves = useAdvancedProcessing ? state.gammaCurves : null;

			if (state.lutFormat === 'png') {
				generate2dPngLUT(lutCanvas, lutCtx, useAdvancedProcessing, gammaCurves);
			} else if (state.lutFormat === 'cube') {
				generate3dCubeLUT(lutCanvas, lutCtx, useAdvancedProcessing, gammaCurves);
			}

			updateProgress('export', 100);
			logMessage('LUT generation complete!', 'success');

			document.getElementById('lut-download-container').style.display = 'block';
		}

		function applyTransformations(r, g, b, useAdvancedProcessing, gammaCurves) {
			let newR, newG, newB;

			if (useAdvancedProcessing) {
				[newR, newG, newB] = processPixelAdvanced(r, g, b, state.transformationModels, state.brightnessAdjustment, gammaCurves);
			} else {
				newR = safeApplyPolynomial(r, state.transformationCoefficients.red);
				newG = safeApplyPolynomial(g, state.transformationCoefficients.green);
				newB = safeApplyPolynomial(b, state.transformationCoefficients.blue);

				newR += state.brightnessAdjustment;
				newG += state.brightnessAdjustment;
				newB += state.brightnessAdjustment;

				const gammaValue = state.gammaValue || 1.0;
				if (gammaValue !== 1.0) {
					newR = safeGamma(newR, gammaValue);
					newG = safeGamma(newG, gammaValue);
					newB = safeGamma(newB, gammaValue);
				}
			}

			return [Math.min(255, Math.max(0, Math.round(newR))),
				Math.min(255, Math.max(0, Math.round(newG))),
				Math.min(255, Math.max(0, Math.round(newB)))];
		}

		function generate2dPngLUT(lutCanvas, lutCtx, useAdvancedProcessing, gammaCurves) {
		  // Set canvas dimensions for 8x8 grid (64 cells)
		  lutCanvas.width = 512;
		  lutCanvas.height = 512;
		  lutCtx.clearRect(0, 0, lutCanvas.width, lutCanvas.height);
		  const lutData = lutCtx.createImageData(512, 512);
		  const data = lutData.data;
		  
		  // Cell size (each cell is 64x64 pixels)
		  const cellSize = 64;
		  
		  // Generate the 8x8 grid of color gradients
		  for (let y = 0; y < 512; y++) {
			for (let x = 0; x < 512; x++) {
			  // Calculate grid position (0-7 for both x and y)
			  const gridX = Math.floor(x / cellSize);
			  const gridY = Math.floor(y / cellSize);
			  
			  // Calculate position within cell (0-63 for both x and y)
			  const cellX = x % cellSize;
			  const cellY = y % cellSize;
			  
			  // Calculate normalized coordinates within cell (0-1)
			  const normalizedX = cellX / (cellSize - 1);
			  const normalizedY = cellY / (cellSize - 1);
			  
			  // Map grid position to base colors
			  // Red varies horizontally across entire width
			  const r = normalizedX * 255;
			  
			  // Green varies vertically
			  const g = normalizedY * 255;
			  
			  // Blue varies by grid position (creating the different hues in each cell)
			  const b = (gridX / 7 + gridY / 7) * 255;
			  
			  // Calculate array index for the current pixel
			  const index = (y * 512 + x) * 4;
			  
			  // Set RGBA values
			  data[index] = r;
			  data[index + 1] = g;
			  data[index + 2] = b;
			  data[index + 3] = 255; // Alpha is always 255 (fully opaque)
			}
		  }
		  
		  // Apply additional transformations if required
		  if (useAdvancedProcessing && typeof applyTransformations === 'function') {
			for (let i = 0; i < data.length; i += 4) {
			  const r = data[i];
			  const g = data[i + 1];
			  const b = data[i + 2];
			  const [newR, newG, newB] = applyTransformations(r, g, b, useAdvancedProcessing, gammaCurves);
			  data[i] = newR;
			  data[i + 1] = newG;
			  data[i + 2] = newB;
			}
		  }
		  
		  // Apply the image data to the canvas
		  lutCtx.putImageData(lutData, 0, 0);
		}

		function generate3dCubeLUT(lutCanvas, lutCtx, useAdvancedProcessing, gammaCurves) {
		  // Default to 333333 grid (standard size for 3D LUTs) or use state.lutSize
		  const size = state.lutSize || 33;
		  
		  // Generate CUBE data
		  let cubeData = [];
		  let header = `# CUBE LUT generated by WebLUT\n`;
		  header += `LUT_3D_SIZE ${size}\n\n`;
		  
		  // Calculate total operations for progress updates
		  const totalOps = size * size * size;
		  let completedOps = 0;
		  
		  logMessage(`Generating ${size}x${size}x${size} CUBE LUT data...`, 'info');
		  
		  // Generate the 3D grid of color values
		  for (let b = 0; b < size; b++) {
			for (let g = 0; g < size; g++) {
			  for (let r = 0; r < size; r++) {
				// Calculate normalized RGB values (0-1)
				const normalizedR = r / (size - 1);
				const normalizedG = g / (size - 1);
				const normalizedB = b / (size - 1);
				
				// Scale to 0-255 for processing
				let rOut = normalizedR * 255;
				let gOut = normalizedG * 255;
				let bOut = normalizedB * 255;
				
				// Apply transformations
				if (useAdvancedProcessing) {
				  [rOut, gOut, bOut] = applyTransformations(rOut, gOut, bOut, useAdvancedProcessing, gammaCurves);
				} else {
				  rOut = safeApplyPolynomial(rOut, state.transformationCoefficients.red);
				  gOut = safeApplyPolynomial(gOut, state.transformationCoefficients.green);
				  bOut = safeApplyPolynomial(bOut, state.transformationCoefficients.blue);
				  
				  rOut += state.brightnessAdjustment;
				  gOut += state.brightnessAdjustment;
				  bOut += state.brightnessAdjustment;
				  
				  const gammaValue = state.gammaValue || 1.0;
				  if (gammaValue !== 1.0) {
					rOut = safeGamma(rOut, gammaValue);
					gOut = safeGamma(gOut, gammaValue);
					bOut = safeGamma(bOut, gammaValue);
				  }
				}
				
				// Clamp values 0-255
				rOut = Math.min(255, Math.max(0, rOut));
				gOut = Math.min(255, Math.max(0, gOut));
				bOut = Math.min(255, Math.max(0, bOut));
				
				// Convert back to 0-1 range for CUBE format
				rOut = rOut / 255;
				gOut = gOut / 255;
				bOut = bOut / 255;
				
				// Format with proper precision and add to data array
				cubeData.push(`${rOut.toFixed(6)} ${gOut.toFixed(6)} ${bOut.toFixed(6)}`);
				
				// Update progress every so often
				completedOps++;
				if (completedOps % Math.floor(totalOps / 10) === 0) {
				  const progress = Math.floor((completedOps / totalOps) * 100);
				  updateProgress('export', progress);
				}
			  }
			}
		  }
		  
		  // Combine header and data
		  const fullCubeData = header + cubeData.join('\n');
		  
		  // Store CUBE data in state for download
		  state.cubeData = fullCubeData;
		  
		  // Generate a visual preview for the CUBE LUT
		  generateCubePreview(lutCanvas, lutCtx);
		  
		  return fullCubeData;
		}
		
		// Generate a visual representation for the CUBE LUT preview
		function generateCubePreview(lutCanvas, lutCtx) {
		  // Set canvas dimensions for preview
		  lutCanvas.width = 512;
		  lutCanvas.height = 512;
		  lutCtx.clearRect(0, 0, lutCanvas.width, lutCanvas.height);
		  
		  // Display size info and create a visual representation
		  lutCtx.fillStyle = '#f8f8f8';
		  lutCtx.fillRect(0, 0, lutCanvas.width, lutCanvas.height);
		  
		  // Draw header info
		  lutCtx.fillStyle = '#333333';
		  lutCtx.font = 'bold 24px sans-serif';
		  lutCtx.fillText(`CUBE LUT (${state.lutSize}${state.lutSize}${state.lutSize})`, 40, 40);
		  
		  // Draw file info
		  lutCtx.font = '16px monospace';
		  lutCtx.fillText(`# CUBE LUT generated by WebLUT`, 40, 70);
		  lutCtx.fillText(`LUT_3D_SIZE ${state.lutSize}`, 40, 95);
		  
		  // Draw a grid representation - slightly smaller and positioned higher
		  const gridSize = Math.min(16, state.lutSize); // Limit grid lines for cleaner visual
		  const cellSize = 280 / gridSize;
		  const startX = 116;
		  const startY = 120;
		  
		  // Draw grid borders
		  lutCtx.strokeStyle = '#666666';
		  lutCtx.lineWidth = 1;
		  
		  // Draw X-Y plane
		  lutCtx.strokeRect(startX, startY, 280, 280);
		  
		  // Draw some sample lines to represent the 3D grid
		  lutCtx.lineWidth = 0.5;
		  for (let i = 1; i < gridSize; i++) {
			// X-Y plane horizontal lines
			lutCtx.beginPath();
			lutCtx.moveTo(startX, startY + i * cellSize);
			lutCtx.lineTo(startX + 280, startY + i * cellSize);
			lutCtx.stroke();
			
			// X-Y plane vertical lines
			lutCtx.beginPath();
			lutCtx.moveTo(startX + i * cellSize, startY);
			lutCtx.lineTo(startX + i * cellSize, startY + 280);
			lutCtx.stroke();
		  }
		  
		  // Indicate file is ready for download
		  lutCtx.font = 'bold 18px sans-serif';
		  lutCtx.fillStyle = '#009900';
		  lutCtx.fillText('CUBE file ready for download!', 156, 420);
		  
		  // Draw legend with sample colors - moved higher up
		  lutCtx.fillStyle = '#333333';
		  lutCtx.font = 'bold 16px sans-serif';
		  lutCtx.fillText('Sample Color Transformations:', 40, 440);
		  
		  // Draw sample color squares with transformations
		  const sampleColors = [
			[0, 0, 0],      // Black
			[255, 0, 0],    // Red
			[0, 255, 0],    // Green
			[0, 0, 255],    // Blue
			[255, 255, 0],  // Yellow
			[255, 0, 255],  // Magenta
			[0, 255, 255],  // Cyan
			[255, 255, 255] // White
		  ];
		  
		  const colorNames = ['Black', 'Red', 'Green', 'Blue', 'Yellow', 'Magenta', 'Cyan', 'White'];
		  
		  // Draw original and transformed color pairs - reorganized in two rows
		  for (let i = 0; i < sampleColors.length; i++) {
			// Position in two rows of 4 items
			const x = 40 + (i % 4) * 120;
			const y = 460 + Math.floor(i / 4) * 40;
			
			const [r, g, b] = sampleColors[i];
			
			// Draw original color
			lutCtx.fillStyle = `rgb(${r},${g},${b})`;
			lutCtx.fillRect(x, y, 15, 15);
			
			// Apply transformation
			const transformedColor = applyTransformations(r, g, b, 
														state.useAdvancedProcessing, 
														state.gammaCurves);
			
			// Ensure valid RGB values
			const [tR, tG, tB] = transformedColor.map(v => Math.min(255, Math.max(0, Math.round(v))));
			
			// Draw transformed color
			lutCtx.fillStyle = `rgb(${tR},${tG},${tB})`;
			lutCtx.fillRect(x + 25, y, 15, 15);
			
			// Draw label
			lutCtx.fillStyle = '#333333';
			lutCtx.font = '12px sans-serif';
			lutCtx.fillText(colorNames[i], x + 50, y + 12);
		  }
		}
		
		// Safe version of applyPolynomial that prevents NaN values
		function safeApplyPolynomial(value, coefficients) {
			if (!coefficients || !Array.isArray(coefficients)) {
				return value;
			}
			
			let result = 0;
			for (let i = 0; i < coefficients.length; i++) {
				const coef = coefficients[i] || 0;
				const term = coef * Math.pow(value, i);
				result += Number.isFinite(term) ? term : 0;
			}
			
			return Number.isFinite(result) ? result : value;
		}

		// Safe version of gamma calculation to prevent NaN
		function safeGamma(value, gamma, isNormalized = false) {
			if (!Number.isFinite(value) || value < 0) return 0;
			if (value === 0) return 0;
			
			let normalizedValue, result;
			
			if (isNormalized) {
				normalizedValue = Math.max(0, Math.min(1, value));
				result = Math.pow(normalizedValue, 1 / (gamma || 1.0));
				// Result is already normalized
			} else {
				normalizedValue = Math.max(0, Math.min(1, value / 255));
				result = Math.pow(normalizedValue, 1 / (gamma || 1.0)) * 255;
			}
			
			return Number.isFinite(result) ? result : value;
		}
		
		function processPixelAdvanced(r, g, b, models, brightnessAdjustment, gammaCurves) {
			// Check if we have multivariate models for each channel
			const hasRedModel = models.multivariate && models.multivariate.red;
			const hasGreenModel = models.multivariate && models.multivariate.green;  
			const hasBlueModel = models.multivariate && models.multivariate.blue;
			
			// Apply transformation based on available models
			let newR = hasRedModel ? 
				applyPoly3d(r, g, b, models.multivariate.red) : 
				safeApplyPolynomial(r, models.basic.red);
			
			let newG = hasGreenModel ? 
				applyPoly3d(r, g, b, models.multivariate.green) : 
				safeApplyPolynomial(g, models.basic.green);
			
			let newB = hasBlueModel ? 
				applyPoly3d(r, g, b, models.multivariate.blue) : 
				safeApplyPolynomial(b, models.basic.blue);
			
			// Apply brightness adjustment
			newR += brightnessAdjustment;
			newG += brightnessAdjustment;
			newB += brightnessAdjustment;
			
			// Apply advanced gamma with roll-off curves if available
			if (gammaCurves) {
				return applyAdvancedGamma(newR, newG, newB, gammaCurves);
			}
			
			return [newR, newG, newB];
		}

		// Safe version of gamma calculation for normalized values (0-1)
		function safeGammaValue(value, gamma) {
			if (!Number.isFinite(value) || value < 0) return 0;
			if (value === 0) return 0;
			
			const normalizedValue = Math.max(0, Math.min(1, value));
			const result = Math.pow(normalizedValue, 1 / (gamma || 1.0));
			
			return Number.isFinite(result) ? result : value;
		}
        
        function downloadLUT() {
		  if (state.lutFormat === 'png') {
			const lutCanvas = document.getElementById('lut-preview');
			
			// Ensure the canvas is properly sized for download
			if (lutCanvas.width !== 512 || lutCanvas.height !== 512) {
			  logMessage('Resizing LUT to full 512x512 for download...', 'info');
			  
			  // Create a temporary canvas for the full-sized LUT
			  const downloadCanvas = document.createElement('canvas');
			  downloadCanvas.width = 512;
			  downloadCanvas.height = 512;
			  
			  // Copy the preview LUT to the download canvas, stretching if needed
			  const downloadCtx = downloadCanvas.getContext('2d');
			  downloadCtx.drawImage(lutCanvas, 0, 0, 512, 512);
			  
			  // Get data URL from the download canvas
			  const dataURL = downloadCanvas.toDataURL('image/png');
			  const a = document.createElement('a');
			  a.href = dataURL;
			  a.download = 'custom-lut.png';
			  a.click();
			} else {
			  // The canvas is already the right size
			  const dataURL = lutCanvas.toDataURL('image/png');
			  const a = document.createElement('a');
			  a.href = dataURL;
			  a.download = 'custom-lut.png';
			  a.click();
			}
		  } else if (state.lutFormat === 'cube' && state.cubeData) {
			// Create blob from cube data
			const blob = new Blob([state.cubeData], { type: 'text/plain' });
			const url = URL.createObjectURL(blob);
			
			// Create temporary link and trigger download
			const a = document.createElement('a');
			a.href = url;
			a.download = 'custom-lut.cube';
			document.body.appendChild(a); // Need to append to body for Firefox
			a.click();
			document.body.removeChild(a); // Clean up
			URL.revokeObjectURL(url);
			
			logMessage('CUBE file downloaded successfully!', 'success');
		  } else {
			logMessage('No LUT data available for download', 'error');
		  }
		}
        
        // Initialize additional event listeners
        function initializeEventListeners() {
            document.getElementById('advanced-processing-toggle').addEventListener('change', function() {
				state.useAdvancedProcessing = this.checked;
				logMessage(`Advanced processing ${this.checked ? 'enabled' : 'disabled'}`, 'info');
			});
        }
		
		        // Display the test image
        function displayTestImage(img) {
            // Original image
            const originalCanvas = document.getElementById('test-original');
            const originalCtx = originalCanvas.getContext('2d');
            
            // Set canvas size
            const maxWidth = 1280;
            const scale = Math.min(1, maxWidth / img.width);
            originalCanvas.width = img.width * scale;
            originalCanvas.height = img.height * scale;
            
            // Draw original image
            originalCtx.drawImage(img, 0, 0, originalCanvas.width, originalCanvas.height);
            
            // Processed image (initial version is same as original)
            const processedCanvas = document.getElementById('test-processed');
            const processedCtx = processedCanvas.getContext('2d');
            
            processedCanvas.width = originalCanvas.width;
            processedCanvas.height = originalCanvas.height;
            processedCtx.drawImage(img, 0, 0, processedCanvas.width, processedCanvas.height);
            
            // Process the test image
            processTestImage();
        }
        
		// Demo image button
		document.getElementById('use-demo-image').addEventListener('click', function() {
			loadDemoImage('colorcard');
		});
			
        // Load a demo image
		function loadDemoImage(type) {
			const demoUrl = type === 'colorcard' 
				? 'logcrop.jpg'
				: 'log.jpg';
			
			logMessage(`Loading demo ${type} image...`, 'info');
			
			fetch(demoUrl)
				.then(response => {
					if (!response.ok) {
						throw new Error(`Failed to load demo image: ${response.status} ${response.statusText}`);
					}
					return response.blob();
				})
				.then(blob => {
					const file = new File([blob], `demo-${type}.jpg`, { type: 'image/jpeg' });
					loadImage(file, type); // Pass the correct type parameter
				})
				.catch(error => {
					logMessage(`Error loading demo image: ${error.message}`, 'error');
				});
		}
        
        // Display the color card image and extract colors
        function displayColorCardImage(img) {
            const canvas = document.getElementById('colorcard-preview');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            const maxWidth = 600;
            const scale = Math.min(1, maxWidth / img.width);
            canvas.width = img.width * scale;
            canvas.height = img.height * scale;
            
            // Draw image
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // Show image info
            const info = document.getElementById('colorcard-info');
            info.textContent = `Image loaded: ${img.width}${img.height} pixels`;
            
            // Extract colors from the image
            extractColorsFromImage(img);
        }
		
		// Demo image button
		document.getElementById('use-demo-test').addEventListener('click', function() {
			loadDemoImage('test');
		});
		
		// Apply adjustments button
		document.getElementById('apply-adjustments').addEventListener('click', function() {
			if (state.testImage) {
				processTestImage();
			}
		});
			
		 // Initialize test image upload
        function initializeTestImageUpload() {
           const testFileInput = document.getElementById('test-upload');
		   if (testFileInput) {
			testFileInput.addEventListener('change', function(event) {
			  const file = event.target.files[0];
			  if (file) {
				loadImage(file, 'test');
				logMessage(`Test image loaded successfully`, 'success');
			  }
			});
		  }
        }
		
		// Advanced multivariate polynomial regression
		function polyfit3d(r, g, b, targetValues, degree) {
			// Create degrees for multivariate polynomial
			const degrees = [];
			for (let i = 0; i < degree; i++) {
				for (let j = 0; j < degree; j++) {
					for (let k = 0; k < degree; k++) {
						degrees.push([i, j, k]);
					}
				}
			}
			
			// Normalize input values for numerical stability
			const rMin = Math.min(...r), rMax = Math.max(...r);
			const gMin = Math.min(...g), gMax = Math.max(...g);
			const bMin = Math.min(...b), bMax = Math.max(...b);
			
			const rRange = rMax - rMin, gRange = gMax - gMin, bRange = bMax - bMin;
			
			// Avoid division by zero
			const normalizedR = rRange === 0 ? r.map(() => 0) : r.map(val => (val - rMin) / rRange);
			const normalizedG = gRange === 0 ? g.map(() => 0) : g.map(val => (val - gMin) / gRange);
			const normalizedB = bRange === 0 ? b.map(() => 0) : b.map(val => (val - bMin) / bRange);
			
			// Create design matrix
			const matrix = [];
			const n = r.length;
			
			for (let i = 0; i < n; i++) {
				const row = [];
				for (const [di, dj, dk] of degrees) {
					// Calculate r^i * g^j * b^k
					row.push(
						Math.pow(normalizedR[i], di) * 
						Math.pow(normalizedG[i], dj) * 
						Math.pow(normalizedB[i], dk)
					);
				}
				matrix.push(row);
			}
			
			// Solve using normal equations (X^T * X)^-1 * X^T * y
			// First calculate X^T * X
			const XtX = [];
			const m = degrees.length;
			
			for (let i = 0; i < m; i++) {
				XtX.push(new Array(m).fill(0));
			}
			
			for (let i = 0; i < m; i++) {
				for (let j = 0; j < m; j++) {
					for (let k = 0; k < n; k++) {
						XtX[i][j] += matrix[k][i] * matrix[k][j];
					}
				}
			}
			
			// Calculate X^T * y
			const Xty = new Array(m).fill(0);
			for (let i = 0; i < m; i++) {
				for (let k = 0; k < n; k++) {
					Xty[i] += matrix[k][i] * targetValues[k];
				}
			}
			
			// Create augmented matrix [XtX|Xty]
			const augmentedMatrix = [];
			for (let i = 0; i < m; i++) {
				augmentedMatrix.push([...XtX[i], Xty[i]]);
			}
			
			// Gaussian elimination
			for (let i = 0; i < m; i++) {
				// Find pivot
				let maxRow = i;
				for (let j = i + 1; j < m; j++) {
					if (Math.abs(augmentedMatrix[j][i]) > Math.abs(augmentedMatrix[maxRow][i])) {
						maxRow = j;
					}
				}
				
				// Swap rows
				if (maxRow !== i) {
					[augmentedMatrix[i], augmentedMatrix[maxRow]] = [augmentedMatrix[maxRow], augmentedMatrix[i]];
				}
				
				// Eliminate below
				for (let j = i + 1; j < m; j++) {
					if (augmentedMatrix[i][i] === 0) continue; // Skip if pivot is zero
					
					const factor = augmentedMatrix[j][i] / augmentedMatrix[i][i];
					for (let k = i; k <= m; k++) {
						augmentedMatrix[j][k] -= factor * augmentedMatrix[i][k];
					}
				}
			}
			
			// Back substitution
			const coefficients = new Array(m).fill(0);
			for (let i = m - 1; i >= 0; i--) {
				if (augmentedMatrix[i][i] === 0) continue; // Skip if diagonal element is zero
				
				let sum = 0;
				for (let j = i + 1; j < m; j++) {
					sum += augmentedMatrix[i][j] * coefficients[j];
				}
				coefficients[i] = (augmentedMatrix[i][m] - sum) / augmentedMatrix[i][i];
			}
			
			return { coefficients, degrees, normalize: { rMin, rMax, gMin, gMax, bMin, bMax } };
}

		function applyPoly3d(r, g, b, model) {
			if (!model || !model.coefficients || !model.degrees) {
				return r; // Return input value as fallback
			}
			
			const { coefficients, degrees, normalize } = model;
			
			// Normalize input values using the same parameters as during training
			let normalizedR = r, normalizedG = g, normalizedB = b;
			
			if (normalize) {
				const { rMin, rMax, gMin, gMax, bMin, bMax } = normalize;
				const rRange = rMax - rMin, gRange = gMax - gMin, bRange = bMax - bMin;
				
				// Avoid division by zero
				normalizedR = rRange === 0 ? 0 : (r - rMin) / rRange;
				normalizedG = gRange === 0 ? 0 : (g - gMin) / gRange;
				normalizedB = bRange === 0 ? 0 : (b - bMin) / bRange;
			}
			
			let result = 0;
			
			for (let i = 0; i < coefficients.length; i++) {
				if (i >= degrees.length) break;
				
				const [di, dj, dk] = degrees[i];
				const coef = coefficients[i] || 0;
				
				// Use a safer approach to calculate powers
				let term = coef;
				
				if (normalizedR !== 0 || di === 0) term *= Math.pow(normalizedR, di);
				if (normalizedG !== 0 || dj === 0) term *= Math.pow(normalizedG, dj);
				if (normalizedB !== 0 || dk === 0) term *= Math.pow(normalizedB, dk);
				
				if (isFinite(term)) {
					result += term;
				}
			}
			
			return isFinite(result) ? result : r;
		}

		function generateGammaCurves() {
			// Create highlight gamma curve (similar to Python LUT2)
			const highlightCurve = new Array(256);
			for (let i = 0; i < 256; i++) {
				// For 225-255 range
				if (i > 225) {
					// Similar to original Python calculation
					// Smoother curve - x is input (225-255), y is output
					const x = i - 225;
					const y = x + Math.pow(x / 30, 0.8) * 30;
					highlightCurve[i] = Math.min(255, Math.max(0, Math.round(225 + y)));
				} else {
					highlightCurve[i] = i;
				}
			}
			
			// Create shadow gamma curve (similar to Python LUT1)
			const shadowCurve = new Array(256);
			for (let i = 0; i < 256; i++) {
				// For 0-30 range
				if (i < 30) {
					// Smoother curve for shadows
					const x = 30 - i;
					const y = x - Math.pow(x / 30, 0.8) * 10;
					shadowCurve[i] = Math.min(255, Math.max(0, Math.round(30 - y)));
				} else {
					shadowCurve[i] = i;
				}
			}
			
			return { highlightCurve, shadowCurve };
		}
		
		function applyAdvancedGamma(r, g, b, curves) {
			const { highlightCurve, shadowCurve } = curves;
			
			// Apply highlight roll-off (when RGB > 225)
			r = r > 225 ? highlightCurve[Math.min(255, Math.round(r))] : r;
			g = g > 225 ? highlightCurve[Math.min(255, Math.round(g))] : g;
			b = b > 225 ? highlightCurve[Math.min(255, Math.round(b))] : b;
			
			// Apply shadow roll-off (when RGB < 30)
			r = r < 30 ? shadowCurve[Math.max(0, Math.round(r))] : r;
			g = g < 30 ? shadowCurve[Math.max(0, Math.round(g))] : g;
			b = b < 30 ? shadowCurve[Math.max(0, Math.round(b))] : b;
			
			return [r, g, b];
		}

		function processColorTransformation() {
			logMessage('Starting color transformation processing...', 'info');
			
			if (state.capturedColors.length === 0) {
				logMessage('No captured colors found. Please upload a color card image first.', 'error');
				return;
			}
			
			if (state.referenceColors.length === 0) {
				logMessage('No reference colors defined. Please set up your reference colors first.', 'error');
				return;
			}
			
			try {
				// Update progress
				updateProgress('process', 10);
				
				// Calculate basic polynomial regression models
				state.transformationCoefficients.red = polynomialRegression(
					state.capturedColors.map(color => color[0]),
					state.referenceColors.map(color => color[0]),
					state.polynomialDegree
				);
				logMessage('Red channel transformation calculated', 'info');
				
				updateProgress('process', 30);
				state.transformationCoefficients.green = polynomialRegression(
					state.capturedColors.map(color => color[1]),
					state.referenceColors.map(color => color[1]),
					state.polynomialDegree
				);
				logMessage('Green channel transformation calculated', 'info');
				
				updateProgress('process', 50);
				state.transformationCoefficients.blue = polynomialRegression(
					state.capturedColors.map(color => color[2]),
					state.referenceColors.map(color => color[2]),
					state.polynomialDegree
				);
				logMessage('Blue channel transformation calculated', 'info');
				
				// Store in models
				state.transformationModels.basic = {
					red: state.transformationCoefficients.red,
					green: state.transformationCoefficients.green,
					blue: state.transformationCoefficients.blue
				};
				
				// If advanced processing is enabled, compute multivariate model
				// Add this error handling to the multivariate model calculation in processColorTransformation function
				if (state.useAdvancedProcessing) {
					updateProgress('process', 60);
					
					try {
						// Create more data points using the basic coefficients
						const gridSize = 3;
						const grid = [];
						const gridValues = [0, 255]; // This matches np.linspace(0,255,2)
						for (let r of gridValues) {
							for (let g of gridValues) {
								for (let b of gridValues) {
									grid.push([r, g, b]);
								}
							}
						}
						
						// Apply basic transformation to grid points
						const transformedGrid = grid.map(([r, g, b]) => [
							applyPolynomial(r, state.transformationCoefficients.red),
							applyPolynomial(g, state.transformationCoefficients.green),
							applyPolynomial(b, state.transformationCoefficients.blue)
						]);
						
						// Combine original captured colors and grid for training data
						const trainColors = [...state.capturedColors, ...grid];
						const trainTargets = [...state.referenceColors, ...transformedGrid];
						
						updateProgress('process', 70);
						
						// Perform multivariate regression for each output channel
						// Use degree 2 for multivariate to avoid overfitting
						const multivariateDegree = 2;
						
						// Prepare input arrays
						const rInputs = trainColors.map(color => color[0]);
						const gInputs = trainColors.map(color => color[1]);
						const bInputs = trainColors.map(color => color[2]);
						
						try {
							state.transformationModels.multivariate.red = polyfit3d(
								rInputs, gInputs, bInputs,
								trainTargets.map(color => color[0]),
								multivariateDegree
							);
							logMessage('Advanced red channel transformation calculated', 'info');
						} catch (error) {
							logMessage(`Error calculating red channel advanced model: ${error.message}. Falling back to basic model.`, 'warning');
							state.transformationModels.multivariate.red = null;
						}
						
						updateProgress('process', 80);
						
						try {
							state.transformationModels.multivariate.green = polyfit3d(
								rInputs, gInputs, bInputs,
								trainTargets.map(color => color[1]),
								multivariateDegree
							);
							logMessage('Advanced green channel transformation calculated', 'info');
						} catch (error) {
							logMessage(`Error calculating green channel advanced model: ${error.message}. Falling back to basic model.`, 'warning');
							state.transformationModels.multivariate.green = null;
						}
						
						updateProgress('process', 90);
						
						try {
							state.transformationModels.multivariate.blue = polyfit3d(
								rInputs, gInputs, bInputs,
								trainTargets.map(color => color[2]),
								multivariateDegree
							);
							logMessage('Advanced blue channel transformation calculated', 'info');
						} catch (error) {
							logMessage(`Error calculating blue channel advanced model: ${error.message}. Falling back to basic model.`, 'warning');
							state.transformationModels.multivariate.blue = null;
						}
						
						// Check if any of the multivariate models failed
						if (!state.transformationModels.multivariate.red || 
							!state.transformationModels.multivariate.green || 
							!state.transformationModels.multivariate.blue) {
							
							logMessage('Some advanced models failed. Partial advanced processing will be used where available.', 'warning');
						}
						
						// Generate gamma curves
						state.gammaCurves = generateGammaCurves();
						logMessage('Gamma curves generated', 'info');
					} catch (error) {
						logMessage(`Advanced processing failed: ${error.message}. Using basic transformation only.`, 'error');
						state.transformationModels.multivariate.red = null;
						state.transformationModels.multivariate.green = null;
						state.transformationModels.multivariate.blue = null;
					}
				}
				
				updateProgress('process', 100);
				logMessage(`Color transformation processing complete!${state.useAdvancedProcessing ? ' (Advanced mode)' : ''}`, 'success');
				
				// Enable next step
				document.getElementById('process-next').disabled = false;
				
				// If a test image is already loaded, process it with the new coefficients
				if (state.testImage) {
					processTestImage();
				}
			} catch (error) {
				logMessage(`Error processing color transformation: ${error}`, 'error');
			}
		}
		
		function processPixelMultivariate(r, g, b, models, brightnessAdjustment, gammaCurves) {
			// Apply multivariate transformation
			const newR = applyPoly3d(r, g, b, models.multivariate.red) + brightnessAdjustment;
			const newG = applyPoly3d(r, g, b, models.multivariate.green) + brightnessAdjustment;
			const newB = applyPoly3d(r, g, b, models.multivariate.blue) + brightnessAdjustment;
			
			// Apply advanced gamma with roll-off curves
			return applyAdvancedGamma(newR, newG, newB, gammaCurves);
		}

		// Generate LUT image with enhanced processing
		function generateEnhancedLUT(transformationModels, brightnessAdjustment, gammaValue) {
			if (!transformationModels) {
				logMessage('No color transformation available. Please process colors first.', 'error');
				return null;
			}
			
			logMessage('Generating enhanced LUT...', 'info');
			
			// Create gamma curves for specialized roll-off
			const gammaCurves = generateGammaCurves();
			
			// For PNG LUT (OBS compatible)
			const lutCanvas = document.createElement('canvas');
			const lutCtx = lutCanvas.getContext('2d');
			lutCanvas.width = 64;
			lutCanvas.height = 64;
			
			// Clear canvas
			lutCtx.clearRect(0, 0, lutCanvas.width, lutCanvas.height);
			
			// Generate neutral LUT data
			const lutData = lutCtx.createImageData(64, 64);
			const data = lutData.data;
			
			// Fill the entire 64x64 grid
			for (let y = 0; y < 64; y++) {
				for (let x = 0; x < 64; x++) {
					// Calculate RGB values from position
					// In 64x64 format, each component (r,g,b) gets 8 values (0-7)
					const r = Math.floor(x % 8) * 255 / 7;     // R cycles every 8 pixels
					const g = Math.floor(x / 8) * 255 / 7;     // G cycles every 8 columns of R
					const b = Math.floor(y / 8) * 255 / 7;     // B changes every 8 rows
					
					// Calculate pixel index
					const index = (y * 64 + x) * 4;
					
					// Set initial RGBA values
					data[index] = r;
					data[index + 1] = g;
					data[index + 2] = b;
					data[index + 3] = 255;  // Alpha
				}
			}
			
			// Apply transformation to LUT
			for (let i = 0; i < data.length; i += 4) {
				// Get original values
				const r = data[i];
				const g = data[i + 1];
				const b = data[i + 2];
				
				// Process pixel with multivariate model
				const [newR, newG, newB] = processPixelMultivariate(
					r, g, b, 
					transformationModels, 
					brightnessAdjustment, 
					gammaCurves
				);
				
				// Clamp values
				data[i] = Math.min(255, Math.max(0, Math.round(newR)));
				data[i + 1] = Math.min(255, Math.max(0, Math.round(newG)));
				data[i + 2] = Math.min(255, Math.max(0, Math.round(newB)));
			}
			
			// Put the data back to the canvas
			lutCtx.putImageData(lutData, 0, 0);
			
			logMessage('Enhanced LUT generation complete!', 'success');
			return lutCanvas;
		}
		
		function applyAdvancedGamma(r, g, b, curves) {
			const { highlightCurve, shadowCurve } = curves;
			
			let newR = r, newG = g, newB = b;
			
			// Apply highlight roll-off (when RGB > 225 and < 492)
			if (newR > 225 && newR < 492) {
				newR = highlightCurve[Math.round(newR) - 226];
			} else if (newR >= 492) {
				newR = 255;
			}
			
			if (newG > 225 && newG < 492) {
				newG = highlightCurve[Math.round(newG) - 226];
			} else if (newG >= 492) {
				newG = 255;
			}
			
			if (newB > 225 && newB < 492) {
				newB = highlightCurve[Math.round(newB) - 226];
			} else if (newB >= 492) {
				newB = 255;
			}
			
			// Apply shadow roll-off (when RGB <= 30 and RGB > -461)
			if (newR <= 30 && newR > -461) {
				newR = shadowCurve[Math.round(newR + 461)];
			} else if (newR <= -461) {
				newR = 0;
			}
			
			if (newG <= 30 && newG > -461) {
				newG = shadowCurve[Math.round(newG + 461)];
			} else if (newG <= -461) {
				newG = 0;
			}
			
			if (newB <= 30 && newB > -461) {
				newB = shadowCurve[Math.round(newB + 461)];
			} else if (newB <= -461) {
				newB = 0;
			}
			
			return [newR, newG, newB];
		}

    </script>
</body>
</html>
